<tool id="flexynesis_plot" name="Flexynesis plot" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@">
    <description>tool for visualizing flexynesis results</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/>
    <command detect_errors="exit_code"><![CDATA[
        @CHECK_NON_COMMERCIAL_USE@
        mkdir -p inputs/ plots/ &&
        ln -s $plot_conditional.labels 'inputs/$plot_conditional.labels.element_identifier.$plot_conditional.labels.ext' &&
        #if $plot_conditional.plot_type == "dimred":
            ln -s $plot_conditional.embeddings 'inputs/$plot_conditional.embeddings.element_identifier.$plot_conditional.embeddings.ext' &&
        #end if
        python '$flexynesis_plot_config'
    ]]></command>
    <configfiles>
        <configfile name="flexynesis_plot_config"><![CDATA[
import sys
sys.path.append('$__tool_directory__/')

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
import torch
from flexynesis import (
    build_cox_model,
    get_important_features,
    plot_dim_reduced,
    plot_hazard_ratios,
    plot_kaplan_meier_curves,
    plot_pr_curves,
    plot_roc_curves,
    plot_scatter
)
from scipy.stats import kruskal, mannwhitneyu
from flexynesis_plot import (
    plot_label_concordance_heatmap,
    plot_boxplot,
    detect_color_type,
    load_labels,
    load_embeddings,
    match_samples_to_embeddings
)
#if $plot_conditional.plot_type == "dimred":
@PLOT_CONFIG@
embeddings, sample_names = load_embeddings('inputs/$plot_conditional.embeddings.element_identifier.$plot_conditional.embeddings.ext')
matched_labels = match_samples_to_embeddings(sample_names, label_data)

color_type = detect_color_type(matched_labels['$plot_conditional.label'])

fig = plot_dim_reduced(
    matrix=embeddings,
    labels=matched_labels['$plot_conditional.label'],
    method='$plot_conditional.method',
    color_type=color_type
)
output_path = "plots/${plot_conditional.label}_${plot_conditional.method}.${plot_conditional.format}"
fig.save(output_path, dpi=$plot_conditional.dpi, bbox_inches='tight')
#else if $plot_conditional.plot_type == "scatter":
@PLOT_CONFIG@
true_values = pd.to_numeric(label_data['$plot_conditional.true_label'], errors='coerce')
predicted_values = pd.to_numeric(label_data['$plot_conditional.predicted_label'], errors='coerce')

if true_values.isna().all() or predicted_values.isna().all():
    raise ValueError("No valid numeric values found for known or predicted labels")

fig = plot_scatter(true_values, predicted_values)

output_path = "plots/${plot_conditional.true_label}_${plot_conditional.predicted_label}_scatter.${plot_conditional.format}"
fig.save(output_path, dpi=$plot_conditional.dpi, bbox_inches='tight')

#else if $plot_conditional.plot_type == "concordance_heatmap":
@PLOT_CONFIG@
true_values = label_data['$plot_conditional.true_label'].tolist()
predicted_values = label_data['$plot_conditional.predicted_label'].tolist()
fig = plot_label_concordance_heatmap(true_values, predicted_values)
plt.close(fig)
output_path = "plots/${plot_conditional.true_label}_${plot_conditional.predicted_label}_concordance_heatmap.${plot_conditional.format}"
fig.savefig(output_path, dpi=$plot_conditional.dpi, bbox_inches='tight')

#else if $plot_conditional.plot_type == "pr_curve":
@PLOT_CONFIG@

# Check if this is a regression problem (no class probabilities)
non_na_probs = label_data['probability'].notna().sum()

print(f"  Non-NaN probabilities: {non_na_probs}/{len(label_data)}")

# If most probabilities are NaN, this is likely a regression problem
if non_na_probs < len(label_data) * 0.1:  # Less than 10% valid probabilities
    raise ValueError("  Detected regression problem - precision-recall curves not applicable")

# Debug: Check data quality
total_rows = len(label_data)
missing_labels = label_data['known_label'].isna().sum()
missing_probs = label_data['probability'].isna().sum()
unique_samples = label_data['sample_id'].nunique()
unique_classes = label_data['class_label'].nunique()

print(f"  Data summary: {total_rows} total rows, {unique_samples} unique samples, {unique_classes} unique classes")
print(f"  Missing data: {missing_labels} missing known_label, {missing_probs} missing probability")

if missing_labels > 0:
    print(f"  Warning: Found {missing_labels} missing known_label values")
    missing_samples = label_data[label_data['known_label'].isna()]['sample_id'].unique()[:5]
    print(f"  Sample IDs with missing known_label: {list(missing_samples)}")

    # Remove rows with missing known_label
    label_data = label_data.dropna(subset=['known_label'])
    if label_data.empty:
        raise ValueError("Error: No valid known_label data remaining")

# 1. Pivot to wide format
prob_df = label_data.pivot(index='sample_id', columns='class_label', values='probability')

print(f"  After pivot: {prob_df.shape[0]} samples x {prob_df.shape[1]} classes")
print(f"  Class columns: {list(prob_df.columns)}")

# Check for NaN values in probability data
nan_counts = prob_df.isna().sum()
if nan_counts.any():
    print(f"  NaN counts per class: {dict(nan_counts)}")
    print(f"  Samples with any NaN: {prob_df.isna().any(axis=1).sum()}/{len(prob_df)}")

    # Drop only rows where ALL probabilities are NaN
    all_nan_rows = prob_df.isna().all(axis=1)
    if all_nan_rows.any():
        print(f"  Dropping {all_nan_rows.sum()} samples with all NaN probabilities")
        prob_df = prob_df[~all_nan_rows]

    remaining_nans = prob_df.isna().sum().sum()
    if remaining_nans > 0:
        print(f"  Warning: {remaining_nans} individual NaN values remain - filling with 0")
        prob_df = prob_df.fillna(0)

    if prob_df.empty:
        raise ValueError(f"  Error: No valid probability data remaining for")

# 2. Get true labels
true_labels_df = label_data.drop_duplicates('sample_id')[['sample_id', 'known_label']].set_index('sample_id')

# 3. Align indices - only keep samples that exist in both datasets
common_indices = prob_df.index.intersection(true_labels_df.index)
if len(common_indices) == 0:
    raise ValueError(f"  Error: No common sample_ids between probability and true label data")

print(f"  Found {len(common_indices)} samples with both probability and true label data")

# Filter both datasets to common indices
prob_df_aligned = prob_df.loc[common_indices]
y_true = true_labels_df.loc[common_indices]['known_label']

# 4. Final check for NaN values
if y_true.isna().any():
    raise ValueError(f"  Error: True labels still contain NaN after alignment")

if prob_df_aligned.isna().any().any():
    raise ValueError(f"  Error: Probability data still contains NaN after alignment")

# 5. Convert categorical labels to integer labels
# Create a mapping from class names to integers
class_names = list(prob_df_aligned.columns)
class_to_int = {class_name: i for i, class_name in enumerate(class_names)}

print(f"  Class mapping: {class_to_int}")

# Convert true labels to integers
y_true_np = y_true.map(class_to_int).to_numpy()
y_probs_np = prob_df_aligned.to_numpy()

print(f"  Data shape: y_true={y_true_np.shape}, y_probs={y_probs_np.shape}")
print(f"  Unique true labels (integers): {set(y_true_np)}")
print(f"  Class labels (columns): {class_names}")
print(f"  Label distribution: {dict(zip(*np.unique(y_true_np, return_counts=True)))}")

# Check for any unmapped labels (will be NaN)
if pd.isna(y_true_np).any():
    raise ValueError("  Error: Some true labels could not be mapped to class columns")

fig = plot_pr_curves(y_true_np, y_probs_np)

output_path = "plots/pr_curves.${plot_conditional.format}"
fig.save(output_path, dpi=$plot_conditional.dpi, bbox_inches='tight')

#end if
        ]]></configfile>
    </configfiles>
    <inputs>
        <param name="non_commercial_use" label="I certify that I am not using this tool for commercial purposes." type="boolean" truevalue="NON_COMMERCIAL_USE" falsevalue="COMMERCIAL_USE" checked="False">
            <validator type="expression" message="This tool is only available for non-commercial use.">value == True</validator>
        </param>
        <conditional name="plot_conditional">
            <param name="plot_type" type="select" label="flexynesis plot">
                <option value="dimred">Dimensionality reduction</option>
                <option value="scatter">Scatter plot of known vs predicted labels</option>
                <option value="concordance_heatmap">Label concordance heatmap</option>
                <option value="pr_curve">Precision-recall curves</option>
                <option value="roc_curve">ROC curves</option>
                <option value="box_plot">Box plot</option>
            </param>
            <when value="dimred">
                <expand macro="plots">
                    <expand macro="common_plot_input"/>
                    <param argument="--embeddings" type="data" format="tabular,csv" label="Embeddings" help="Generated by flexynesis"/>
                    <param argument="--label" type="text" label="Labels" help="column name in the labels file to use for coloring the points in the plot.">
                        <sanitizer invalid_char="">
                            <valid initial="string.printable"></valid>
                        </sanitizer>
                    </param>
                    <param name="method" type="select" label="Transformation method">
                        <option value="pca" selected="true">PCA</option>
                        <option value="umap">UMAP</option>
                    </param>
                </expand>
            </when>
            <when value="scatter">
                <expand macro="plots">
                    <expand macro="common_plot_input"/>
                    <param name="true_label" type="text" label="True label" help="column name in the labels file to use for the true labels.">
                        <sanitizer invalid_char="">
                            <valid initial="string.printable"></valid>
                        </sanitizer>
                    </param>
                    <param name="predicted_label" type="text" label="Predicted label" help="column name in the labels file to use for the predicted labels.">
                        <sanitizer invalid_char="">
                            <valid initial="string.printable"></valid>
                        </sanitizer>
                    </param>
                </expand>
            </when>
            <when value="concordance_heatmap">
                <expand macro="plots">
                    <expand macro="common_plot_input"/>
                    <param name="true_label" type="text" label="True label" help="column name in the labels file to use for the true labels.">
                        <sanitizer invalid_char="">
                            <valid initial="string.printable"></valid>
                        </sanitizer>
                    </param>
                    <param name="predicted_label" type="text" label="Predicted label" help="column name in the labels file to use for the predicted labels.">
                        <sanitizer invalid_char="">
                            <valid initial="string.printable"></valid>
                        </sanitizer>
                    </param>
                </expand>
            </when>
            <when value="pr_curve">
                <expand macro="plots">
                    <expand macro="common_plot_input"/>
                </expand>
            </when>
            <when value="roc_curve">
                <expand macro="plots">
                    <expand macro="common_plot_input"/>
                </expand>
            </when>
            <when value="box_plot">
                <expand macro="plots">
                    <expand macro="common_plot_input"/>
                </expand>
            </when>
        </conditional>
    </inputs>
    <outputs>
        <data name="plot_out" auto_format="true" from_work_dir="plots/*"/>
    </outputs>
    <tests>
        <test>
            <param name="non_commercial_use" value="True"/>
            <conditional name="plot_conditional">
                <param name="plot_type" value="dimred"/>
                <param name="embeddings" value="embeddings.csv"/>
                <param name="label" value="predicted_label"/>
                <param name="method" value="pca"/>
                <param name="labels" value="labels.csv"/>
                <param name="format" value="jpg"/>
                <param name="dpi" value="300"/>
            </conditional>
            <output name="plot_out">
                <assert_contents>
                    <has_image_center_of_mass center_of_mass="970,733" eps="50"/>
                    <has_image_channels channels="3"/>
                    <has_image_height height="1461" delta="50"/>
                    <has_image_width width="1941" delta="50"/>
                </assert_contents>
            </output>
        </test>
        <test>
            <param name="non_commercial_use" value="True"/>
            <conditional name="plot_conditional">
                <param name="plot_type" value="scatter"/>
                <param name="labels" value="labels_scatter.csv"/>
                <param name="true_label" value="known_label"/>
                <param name="predicted_label" value="predicted_label"/>
                <param name="format" value="jpg"/>
                <param name="dpi" value="300"/>
            </conditional>
            <output name="plot_out">
                <assert_contents>
                    <has_image_center_of_mass center_of_mass="970,733" eps="50"/>
                    <has_image_channels channels="3"/>
                    <has_image_height height="1461" delta="50"/>
                    <has_image_width width="1941" delta="50"/>
                </assert_contents>
            </output>
        </test>
        <test>
            <param name="non_commercial_use" value="True"/>
            <conditional name="plot_conditional">
                <param name="plot_type" value="concordance_heatmap"/>
                <param name="labels" value="labels.csv"/>
                <param name="true_label" value="known_label"/>
                <param name="predicted_label" value="predicted_label"/>
                <param name="format" value="jpg"/>
                <param name="dpi" value="300"/>
            </conditional>
            <output name="plot_out">
                <assert_contents>
                    <has_image_center_of_mass center_of_mass="1450,1310" eps="50"/>
                    <has_image_channels channels="3"/>
                    <has_image_height height="2558" delta="50"/>
                    <has_image_width width="2770" delta="50"/>
                </assert_contents>
            </output>
        </test>
        <test>
            <param name="non_commercial_use" value="True"/>
            <conditional name="plot_conditional">
                <param name="plot_type" value="pr_curve"/>
                <param name="labels" value="labels_pr.csv"/>
                <param name="format" value="jpg"/>
                <param name="dpi" value="300"/>
            </conditional>
            <output name="plot_out">
                <assert_contents>
                    <has_image_center_of_mass center_of_mass="970,733" eps="50"/>
                    <has_image_channels channels="3"/>
                    <has_image_height height="1461" delta="50"/>
                    <has_image_width width="1941" delta="50"/>
                </assert_contents>
            </output>
        </test>
    </tests>
    <help><![CDATA[
    **Flexynesis plot**



    ]]></help>
    <citations>
        <citation type="doi">10.1101/2024.07.16.603606</citation>
    </citations>
</tool>
<tool id="flexynesis_utils" name="Flexynesis utils" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@">
    <description>Utility functions for Flexynesis</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/>
    <command detect_errors="exit_code"><![CDATA[
        @CHECK_NON_COMMERCIAL_USE@
        mkdir -p inputs/ output/ &&
        ln -s $utils_conditional.labels 'inputs/$utils_conditional.labels.element_identifier.$utils_conditional.labels.ext' &&
        #if $utils_conditional.util != "compute_ami_ari":
            ln -s $utils_conditional.X 'inputs/$utils_conditional.X.element_identifier.$utils_conditional.X.ext' &&
        #end if
        python '$flexynesis_utils_config'
    ]]></command>
    <configfiles>
        <configfile name="flexynesis_utils_config"><![CDATA[
import sys
sys.path.append('$__tool_directory__/')

import numpy as np
import pandas as pd
from flexynesis import (
    louvain_clustering,
    get_optimal_clusters,
    compute_ami_ari,
    k_means_clustering
)

from flexynesis_plot import (
    load_omics
)

#if $utils_conditional.util == "louvain_clustering":
label_data = load_omics('inputs/$utils_conditional.labels.element_identifier.$utils_conditional.labels.ext')
X = load_omics('inputs/$utils_conditional.X.element_identifier.$utils_conditional.X.ext')

cluster_labels, G, partition = louvain_clustering(
                                #if $utils_conditional.threshold != "":
                                threshold=$utils_conditional.threshold,
                                #end if
                                #if $utils_conditional.k != "":
                                k=$utils_conditional.k,
                                #end if
                                X=X)
cluster_df = pd.DataFrame(data=cluster_labels, index=X.index, columns=['louvain_cluster'])
label_data = label_data.merge(cluster_df[['louvain_cluster']], left_index=True, right_index=True, how='left')

output_path = f"output/clustered_labels.csv"
label_data.to_csv(output_path, index=True)

#else if $utils_conditional.util == "get_optimal_clusters":
label_data = load_omics('inputs/$utils_conditional.labels.element_identifier.$utils_conditional.labels.ext')
X = load_omics('inputs/$utils_conditional.X.element_identifier.$utils_conditional.X.ext')

kmeans_cluster_labels, optimal_k, silhouette_scores = get_optimal_clusters(
                                                        data=X,
                                                        min_k=$utils_conditional.min_k,
                                                        max_k=$utils_conditional.max_k)

print(f"Optimal number of clusters: {optimal_k}\n")
print(f"Silhouette scores: \n{silhouette_scores}")

cluster_df = pd.DataFrame(data=kmeans_cluster_labels, index=X.index, columns=['optimal_kmeans_cluster'])
label_data = label_data.merge(cluster_df[['optimal_kmeans_cluster']], left_index=True, right_index=True, how='left')

output_path = f"output/optimal_clusters_labels.csv"
label_data.to_csv(output_path, index=True)

#else if $utils_conditional.util == "k_means_clustering":
label_data = load_omics('inputs/$utils_conditional.labels.element_identifier.$utils_conditional.labels.ext')
X = load_omics('inputs/$utils_conditional.X.element_identifier.$utils_conditional.X.ext')

cluster_labels, kmeans = k_means_clustering(
                            data=X,
                            k=$utils_conditional.k)

print(f"{kmeans}")
cluster_df = pd.DataFrame(data=cluster_labels, index=X.index, columns=['kmeans_cluster'])
label_data = label_data.merge(cluster_df[['kmeans_cluster']], left_index=True, right_index=True, how='left')

output_path = f"output/kmeans_labels.csv"
label_data.to_csv(output_path, index=True)

#else if $utils_conditional.util == "compute_ami_ari":
label_data = load_omics('inputs/$utils_conditional.labels.element_identifier.$utils_conditional.labels.ext')
true_labels = label_data['$utils_conditional.true_label']
predicted_labels = label_data['$utils_conditional.predicted_label']

ami_ari = compute_ami_ari(labels1=true_labels, labels2=predicted_labels)

print(f"AMI: {ami_ari['ami']}")
print(f"ARI: {ami_ari['ari']}")

output_path = f"output/ami_ari.txt"
with open(output_path, 'w') as f:
    f.write(f"AMI: {ami_ari['ami']}\n")
    f.write(f"ARI: {ami_ari['ari']}\n")

#end if
        ]]></configfile>
    </configfiles>
    <inputs>
        <param name="non_commercial_use" label="I certify that I am not using this tool for commercial purposes." type="boolean" truevalue="NON_COMMERCIAL_USE" falsevalue="COMMERCIAL_USE" checked="False">
            <validator type="expression" message="This tool is only available for non-commercial use.">value == True</validator>
        </param>
        <conditional name="utils_conditional">
            <param name="util" type="select" label="flexynesis utils">
                <option value="louvain_clustering">Louvain Clustering</option>
                <option value="get_optimal_clusters">Get Optimal Clusters</option>
                <option value="k_means_clustering">K-Means Clustering</option>
                <option value="compute_ami_ari">Compute AMI and ARI</option>
                <option value="find_optimal_cutoff">Find Optimal Cutoff</option>
            </param>
            <when value="louvain_clustering">
                <param argument="--X" type="data" format="tabular,csv" label="Matrix" help="Input matrix, (samples, features)"/>
                <expand macro="common_plot_input"/>
                <param argument="--threshold" type="float" min="0" optional="true" label="Distance threshold to create an edge between two nodes"/>
                <param argument="--k" type="integer" min="0" optional="true" label="Number of nearest neighbors to connect for each node"/>
            </when>
            <when value="get_optimal_clusters">
                <param argument="--X" type="data" format="tabular,csv" label="Matrix" help="Input matrix, (samples, features)"/>
                <expand macro="common_plot_input"/>
                <param argument="--min_k" type="integer" min="0" value="2" optional="false" label="Minimum number of clusters to try"/>
                <param argument="--max_k" type="integer" min="0" value="10" optional="false" label="Maximum number of clusters to try"/>
            </when>
            <when value="k_means_clustering">
                <param argument="--X" type="data" format="tabular,csv" label="Matrix" help="Input matrix, (samples, features)"/>
                <expand macro="common_plot_input"/>
                <param argument="--k" type="integer" min="0" optional="true" label="The number of clusters to form"/>
            </when>
            <when value="compute_ami_ari">
                <expand macro="common_plot_input"/>
                <param name="true_label" type="text" label="True label" help="column name in the labels file to use for the true labels.">
                    <sanitizer invalid_char="">
                        <valid initial="string.printable"></valid>
                    </sanitizer>
                </param>
                <param name="predicted_label" type="text" label="Predicted label" help="column name in the labels file to use for the predicted labels.">
                    <sanitizer invalid_char="">
                        <valid initial="string.printable"></valid>
                    </sanitizer>
                </param>
            </when>
            <when value="find_optimal_cutoff">

            </when>
        </conditional>
    </inputs>
    <outputs>
        <data name="util_out" auto_format="true" from_work_dir="output/*">
        </data>
    </outputs>
    <tests>
        <test>
            <param name="non_commercial_use" value="NON_COMMERCIAL_USE"/>
            <conditional name="utils_conditional">
                <param name="util" value="louvain_clustering"/>
                <param name="X" value="embeddings.csv"/>
                <param name="labels" value="labels_pr.csv"/>
                <param name="k" value="15"/>
            </conditional>
            <output name="util_out">
                <assert_contents>
                    <has_text text="sample_id,variable,class_label,probability,known_label,predicted_label,split,louvain_cluster"/>
                    <has_text text="MB-4818,CLAUDIN_SUBTYPE,LumA,0.8582904,LumB,LumA,test,3.0"/>
                </assert_contents>
            </output>
        </test>
        <test>
            <param name="non_commercial_use" value="NON_COMMERCIAL_USE"/>
            <conditional name="utils_conditional">
                <param name="util" value="get_optimal_clusters"/>
                <param name="X" value="embeddings.csv"/>
                <param name="labels" value="labels_pr.csv"/>
                <param name="min_k" value="2"/>
                <param name="max_k" value="10"/>
            </conditional>
            <assert_stdout>
                <has_text text="Optimal number of clusters: 2"/>
                <has_text text="Silhouette scores: "/>
            </assert_stdout>
            <output name="util_out">
                <assert_contents>
                    <has_text text="sample_id,variable,class_label,probability,known_label,predicted_label,split,optimal_kmeans_cluster"/>
                    <has_text text="MB-4818,CLAUDIN_SUBTYPE,LumA,0.8582904,LumB,LumA,test,0.0"/>
                </assert_contents>
            </output>
        </test>
        <test>
            <param name="non_commercial_use" value="NON_COMMERCIAL_USE"/>
            <conditional name="utils_conditional">
                <param name="util" value="k_means_clustering"/>
                <param name="X" value="embeddings.csv"/>
                <param name="labels" value="labels_pr.csv"/>
                <param name="k" value="2"/>
            </conditional>
            <assert_stdout>
                <has_text text="KMeans(n_clusters=2, random_state=42)"/>
            </assert_stdout>
            <output name="util_out">
                <assert_contents>
                    <has_text text="sample_id,variable,class_label,probability,known_label,predicted_label,split,kmeans_cluster"/>
                    <has_text text="MB-4818,CLAUDIN_SUBTYPE,LumA,0.8582904,LumB,LumA,test,0.0"/>
                </assert_contents>
            </output>
        </test>
        <test>
            <param name="non_commercial_use" value="NON_COMMERCIAL_USE"/>
            <conditional name="utils_conditional">
                <param name="util" value="compute_ami_ari"/>
                <param name="labels" value="labels.csv"/>
                <param name="true_label" value="known_label"/>
                <param name="predicted_label" value="predicted_label"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="AMI: 0.5108[0-9]+"/>
                <has_text_matching expression="ARI: 0.5258[0-9]+"/>
            </assert_stdout>
            <output name="util_out">
                <assert_contents>
                    <has_text_matching expression="AMI: 0.5108[0-9]+"/>
                    <has_text_matching expression="ARI: 0.5258[0-9]+"/>
                </assert_contents>
            </output>
        </test>
    </tests>
    <help>
COMMON_HELP




.. _Documentation: https://bimsbstatic.mdc-berlin.de/akalin/buyar/flexynesis/site/
.. _copyright holders: https://github.com/BIMSBbioinfo/flexynesis
    </help>
    <citations>
        <citation type="doi">10.1101/2024.07.16.603606</citation>
    </citations>
</tool>
<tool id="flexynesis_utils" name="Flexynesis utils" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@">
    <description>Utility functions for Flexynesis</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/>
    <command detect_errors="exit_code"><![CDATA[
        @CHECK_NON_COMMERCIAL_USE@
        mkdir -p inputs/ output/ &&
        #if $utils_conditional.util != "search_cbio":
            ln -s $utils_conditional.labels 'inputs/$utils_conditional.labels.element_identifier.$utils_conditional.labels.ext' &&
        #end if
        #if $utils_conditional.util != "compute_ami_ari" and $utils_conditional.util != "search_cbio":
            ln -s $utils_conditional.X 'inputs/$utils_conditional.X.element_identifier.$utils_conditional.X.ext' &&
        #end if
        cat '$flexynesis_utils_config' &&
        python '$flexynesis_utils_config'
    ]]></command>
    <configfiles>
        <configfile name="flexynesis_utils_config"><![CDATA[
import sys
sys.path.append('$__tool_directory__/')

import numpy as np
import pandas as pd
from flexynesis import (
    louvain_clustering,
    get_optimal_clusters,
    compute_ami_ari,
    k_means_clustering
)

from flexynesis_plot import (
    load_omics
)

#if $utils_conditional.util == "louvain_clustering":
label_data = load_omics('inputs/$utils_conditional.labels.element_identifier.$utils_conditional.labels.ext')
X = load_omics('inputs/$utils_conditional.X.element_identifier.$utils_conditional.X.ext')

cluster_labels, G, partition = louvain_clustering(
                                #if $utils_conditional.threshold != "":
                                threshold=$utils_conditional.threshold,
                                #end if
                                #if $utils_conditional.k != "":
                                k=$utils_conditional.k,
                                #end if
                                X=X)
cluster_df = pd.DataFrame(data=cluster_labels, index=X.index, columns=['louvain_cluster'])
label_data = label_data.merge(cluster_df[['louvain_cluster']], left_index=True, right_index=True, how='left')

output_path = f"output/clustered_labels.csv"
label_data.to_csv(output_path, index=True)

#else if $utils_conditional.util == "get_optimal_clusters":
label_data = load_omics('inputs/$utils_conditional.labels.element_identifier.$utils_conditional.labels.ext')
X = load_omics('inputs/$utils_conditional.X.element_identifier.$utils_conditional.X.ext')

kmeans_cluster_labels, optimal_k, silhouette_scores = get_optimal_clusters(
                                                        data=X,
                                                        min_k=$utils_conditional.min_k,
                                                        max_k=$utils_conditional.max_k)

print(f"Optimal number of clusters: {optimal_k}\n")
print(f"Silhouette scores: \n{silhouette_scores}")

cluster_df = pd.DataFrame(data=kmeans_cluster_labels, index=X.index, columns=['optimal_kmeans_cluster'])
label_data = label_data.merge(cluster_df[['optimal_kmeans_cluster']], left_index=True, right_index=True, how='left')

output_path = f"output/optimal_clusters_labels.csv"
label_data.to_csv(output_path, index=True)

#else if $utils_conditional.util == "k_means_clustering":
label_data = load_omics('inputs/$utils_conditional.labels.element_identifier.$utils_conditional.labels.ext')
X = load_omics('inputs/$utils_conditional.X.element_identifier.$utils_conditional.X.ext')

cluster_labels, kmeans = k_means_clustering(
                            data=X,
                            k=$utils_conditional.k)

print(f"{kmeans}")
cluster_df = pd.DataFrame(data=cluster_labels, index=X.index, columns=['kmeans_cluster'])
label_data = label_data.merge(cluster_df[['kmeans_cluster']], left_index=True, right_index=True, how='left')

output_path = f"output/kmeans_labels.csv"
label_data.to_csv(output_path, index=True)

#else if $utils_conditional.util == "compute_ami_ari":
label_data = load_omics('inputs/$utils_conditional.labels.element_identifier.$utils_conditional.labels.ext')
true_labels = label_data['$utils_conditional.true_label']
predicted_labels = label_data['$utils_conditional.predicted_label']

ami_ari = compute_ami_ari(labels1=true_labels, labels2=predicted_labels)

print(f"AMI: {ami_ari['ami']}")
print(f"ARI: {ami_ari['ari']}")

output_path = f"output/ami_ari.txt"
with open(output_path, 'w') as f:
    f.write(f"AMI: {ami_ari['ami']}\n")
    f.write(f"ARI: {ami_ari['ari']}\n")

#else if $utils_conditional.util == "search_cbio":
from flexynesis import CBioPortalData
from contextlib import redirect_stdout

study_id = '$utils_conditional.study_id'
cbio = CBioPortalData(study_id=study_id)

output_path = f"output/cbioportal_data.txt"
with open(output_path, 'w') as f:
    with redirect_stdout(f):
        cbio.get_cbioportal_data(study_id)
#end if
        ]]></configfile>
    </configfiles>
    <inputs>
        <param name="non_commercial_use" label="I certify that I am not using this tool for commercial purposes." type="boolean" truevalue="NON_COMMERCIAL_USE" falsevalue="COMMERCIAL_USE" checked="False">
            <validator type="expression" message="This tool is only available for non-commercial use.">value == True</validator>
        </param>
        <conditional name="utils_conditional">
            <param name="util" type="select" label="flexynesis utils">
                <option value="louvain_clustering">Louvain Clustering</option>
                <option value="get_optimal_clusters">Get Optimal Clusters</option>
                <option value="k_means_clustering">K-Means Clustering</option>
                <option value="compute_ami_ari">Compute AMI and ARI</option>
                <option value="search_cbio">Search available cBioPortal data</option>
            </param>
            <when value="louvain_clustering">
                <param argument="--X" type="data" format="tabular,csv" label="Matrix" help="Input matrix, (samples, features)"/>
                <expand macro="common_plot_input"/>
                <param argument="--threshold" type="float" min="0" optional="true" label="Distance threshold to create an edge between two nodes"/>
                <param argument="--k" type="integer" min="0" optional="true" label="Number of nearest neighbors to connect for each node"/>
            </when>
            <when value="get_optimal_clusters">
                <param argument="--X" type="data" format="tabular,csv" label="Matrix" help="Input matrix, (samples, features)"/>
                <expand macro="common_plot_input"/>
                <param argument="--min_k" type="integer" min="0" value="2" optional="false" label="Minimum number of clusters to try"/>
                <param argument="--max_k" type="integer" min="0" value="10" optional="false" label="Maximum number of clusters to try"/>
            </when>
            <when value="k_means_clustering">
                <param argument="--X" type="data" format="tabular,csv" label="Matrix" help="Input matrix, (samples, features)"/>
                <expand macro="common_plot_input"/>
                <param argument="--k" type="integer" min="0" optional="true" label="The number of clusters to form"/>
            </when>
            <when value="compute_ami_ari">
                <expand macro="common_plot_input"/>
                <param name="true_label" type="text" label="True label" value="known_label" optional="false" help="column name in the labels file to use for the true labels.">
                    <sanitizer invalid_char="">
                        <valid initial="string.printable"></valid>
                    </sanitizer>
                </param>
                <param name="predicted_label" type="text" label="Predicted label" value="predicted_label" optional="false" help="column name in the labels file to use for the predicted labels.">
                    <sanitizer invalid_char="">
                        <valid initial="string.printable"></valid>
                    </sanitizer>
                </param>
            </when>
            <when value="search_cbio">
                <param name="study_id" type="text" label="cBioPortal study ID" help="The ID of the study to fetch from cBioPortal (e.g., 'brca_tcga')." />
            </when>
        </conditional>
    </inputs>
    <outputs>
        <data name="util_out" auto_format="true" from_work_dir="output/*" label="${tool.name} on ${on_string}: ${utils_conditional.util}">
        </data>
    </outputs>
    <tests>
        <test>
            <param name="non_commercial_use" value="True"/>
            <conditional name="utils_conditional">
                <param name="util" value="louvain_clustering"/>
                <param name="X" value="embeddings.csv"/>
                <param name="labels" value="labels_pr.csv"/>
                <param name="k" value="15"/>
            </conditional>
            <output name="util_out">
                <assert_contents>
                    <has_text text="sample_id,variable,class_label,probability,known_label,predicted_label,split,louvain_cluster"/>
                    <has_text text="MB-4818,CLAUDIN_SUBTYPE,LumA,0.8582904,LumB,LumA,test,3.0"/>
                </assert_contents>
            </output>
        </test>
        <test>
            <param name="non_commercial_use" value="True"/>
            <conditional name="utils_conditional">
                <param name="util" value="get_optimal_clusters"/>
                <param name="X" value="embeddings.csv"/>
                <param name="labels" value="labels_pr.csv"/>
                <param name="min_k" value="2"/>
                <param name="max_k" value="10"/>
            </conditional>
            <assert_stdout>
                <has_text text="Optimal number of clusters: 2"/>
                <has_text text="Silhouette scores: "/>
            </assert_stdout>
            <output name="util_out">
                <assert_contents>
                    <has_text text="sample_id,variable,class_label,probability,known_label,predicted_label,split,optimal_kmeans_cluster"/>
                    <has_text text="MB-4818,CLAUDIN_SUBTYPE,LumA,0.8582904,LumB,LumA,test,0.0"/>
                </assert_contents>
            </output>
        </test>
        <test>
            <param name="non_commercial_use" value="True"/>
            <conditional name="utils_conditional">
                <param name="util" value="k_means_clustering"/>
                <param name="X" value="embeddings.csv"/>
                <param name="labels" value="labels_pr.csv"/>
                <param name="k" value="2"/>
            </conditional>
            <assert_stdout>
                <has_text text="KMeans(n_clusters=2, random_state=42)"/>
            </assert_stdout>
            <output name="util_out">
                <assert_contents>
                    <has_text text="sample_id,variable,class_label,probability,known_label,predicted_label,split,kmeans_cluster"/>
                    <has_text text="MB-4818,CLAUDIN_SUBTYPE,LumA,0.8582904,LumB,LumA,test,0.0"/>
                </assert_contents>
            </output>
        </test>
        <test>
            <param name="non_commercial_use" value="True"/>
            <conditional name="utils_conditional">
                <param name="util" value="compute_ami_ari"/>
                <param name="labels" value="labels.csv"/>
                <param name="true_label" value="known_label"/>
                <param name="predicted_label" value="predicted_label"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="AMI: 0.5108[0-9]+"/>
                <has_text_matching expression="ARI: 0.5258[0-9]+"/>
            </assert_stdout>
            <output name="util_out">
                <assert_contents>
                    <has_text_matching expression="AMI: 0.5108[0-9]+"/>
                    <has_text_matching expression="ARI: 0.5258[0-9]+"/>
                </assert_contents>
            </output>
        </test>
        <test>
            <param name="non_commercial_use" value="True"/>
            <conditional name="utils_conditional">
                <param name="util" value="search_cbio"/>
                <param name="study_id" value="brca_tcga"/>
            </conditional>
            <output name="util_out">
                <assert_contents>
                    <has_text text="Available Data Files"/>
                    <has_text text="data_cna.txt"/>
                    <has_text text="data_clinical_patient.txt"/>
                    <has_text text="data_mutations.txt"/>
                </assert_contents>
            </output>
        </test>
    </tests>
    <help><![CDATA[
COMMON_HELP

Flexynesis Utils provides a collection of clustering and evaluation utilities for multi-omics data analysis. This tool offers four main functionalities:

1. **Louvain Clustering**: Community detection clustering algorithm that partitions data into clusters based on network modularity optimization
2. **Get Optimal Clusters**: Determines the optimal number of clusters using K-means clustering with silhouette score evaluation
3. **K-Means Clustering**: Standard K-means clustering algorithm for partitioning data into k clusters
4. **Compute AMI and ARI**: Calculates Adjusted Mutual Information (AMI) and Adjusted Rand Index (ARI) to evaluate clustering performance
5. **Search cBioPortal**: Fetches available data files from cBioPortal for a specified study ID

**Louvain Clustering**
    Uses the Louvain algorithm for community detection in networks. This method builds a graph from the input data and finds communities (clusters) by optimizing modularity.

    Outputs Original labels file with added 'louvain_cluster' column

**Get Optimal Clusters**
    Performs K-means clustering for a range of k values and determines the optimal number of clusters using silhouette analysis.

    Outputs Original labels file with added 'optimal_kmeans_cluster' column
    Console output shows the optimal k value and silhouette scores for each k.

**K-Means Clustering**
    Standard K-means clustering algorithm that partitions data into k clusters by minimizing within-cluster sum of squares.

    Outputs Original labels file with added 'kmeans_cluster' column

**Compute AMI and ARI**
    Evaluates clustering performance by comparing true labels with predicted labels using two standard metrics:
    - *AMI (Adjusted Mutual Information)*: Measures mutual information between clusterings, adjusted for chance
    - *ARI (Adjusted Rand Index)*: Measures similarity between clusterings, adjusted for chance

    Outputs Text file containing AMI and ARI scores
    Both metrics range from 0 to 1, where 1 indicates perfect agreement

**Search cBioPortal**
    Fetches available data files from cBioPortal for a specified study ID. This allows users to explore and retrieve data from cBioPortal studies.
    Outputs a text file listing available data files for the specified study ID

.. _Documentation: https://bimsbstatic.mdc-berlin.de/akalin/buyar/flexynesis/site/
.. _copyright holders: https://github.com/BIMSBbioinfo/flexynesis
    ]]></help>
    <expand macro="citations" />
</tool>
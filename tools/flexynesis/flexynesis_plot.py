#!/usr/bin/env python

import argparse
import os
import numpy as np
import pandas as pd
from pathlib import Path
from flexynesis import plot_dim_reduced

def load_matrix(matrix_path):
    try:
        # Determine file extension
        file_ext = Path(matrix_path).suffix.lower()

        if file_ext == '.csv':

            df = pd.read_csv(matrix_path, index_col=0)

        elif file_ext in ['.tsv', '.txt', '.tab', '.tabular']:

            df = pd.read_csv(matrix_path, sep='\t', index_col=0)

        return df, df.index.tolist()

    except Exception as e:
        raise ValueError(f"Error loading matrix from {matrix_path}: {e}")

def load_labels(labels_input):
    """Load predicted labels from flexynesis"""
    try:
        # Determine file extension
        file_ext = Path(labels_input).suffix.lower()

        if file_ext == '.csv':

            df = pd.read_csv(labels_input)

        elif file_ext in ['.tsv', '.txt', '.tab', '.tabular']:

            df = pd.read_csv(labels_input, sep='\t')

        # Check if this is the specific format with sample_id, known_label, predicted_label
        required_cols = ['sample_id', 'known_label', 'predicted_label']
        if all(col in df.columns for col in required_cols):
            df = df.drop_duplicates(subset='sample_id')
            return df
        else:

            raise ValueError(f"Labels file {labels_input} does not contain required columns: {required_cols}")

    except Exception as e:
        raise ValueError(f"Error loading labels from {labels_input}: {e}")

def match_samples_to_matrix(sample_names, label_data):
    """Filter label data to match sample names in the matrix"""

    df_matched = label_data[label_data['sample_id'].isin(sample_names)]

    return df_matched

def main():
    parser = argparse.ArgumentParser(description="Generate dimensionality reduction plots using flexynesis")
    parser.add_argument("--matrix", type=str, required=True,
                       help="Path to input data matrix file (CSV or tabular format)")
    parser.add_argument("--labels", type=str, required=True,
                       help="Path to labels file generated by flexynesis")
    parser.add_argument("--method", type=str, default='pca', choices=['pca', 'umap'],
                       help="Transformation method ('pca' or 'umap'). Default is 'pca'")
    parser.add_argument("--color_type", type=str, default='categorical', choices=['categorical', 'numerical'],
                       help="Type of the color scale ('categorical' or 'numerical'). Default is 'categorical'")
    parser.add_argument("--title", type=str, required=False,
                       help="Optional title for the plot")
    parser.add_argument("--output_dir", type=str, default='output',
                       help="Output directory. Default is 'output'")
    parser.add_argument("--output_name", type=str, default=None,
                       help="Output filename")
    parser.add_argument("--format", type=str, default='jpg', choices=['png', 'pdf', 'svg', 'jpg'],
                       help="Output format for the plot. Default is 'jpg'")
    parser.add_argument("--dpi", type=int, default=300,
                       help="DPI for the output image. Default is 300")

    args = parser.parse_args()

    try:
        # check the inputs
        if not os.path.isfile(args.matrix):
            raise FileNotFoundError(f"Matrix file not found: {args.matrix}")

        if args.method not in ['pca', 'umap']:
            raise ValueError("Method must be 'pca' or 'umap'")

        if args.color_type not in ['categorical', 'numerical']:
            raise ValueError("Color type must be 'categorical' or 'numerical'")

        # Load data
        print(f"Loading matrix from: {args.matrix}")
        matrix, sample_names = load_matrix(args.matrix)
        print(f"Matrix shape: {matrix.shape}")

        print(f"Loading labels from: {args.labels}")
        label_data = load_labels(args.labels)

        # Match samples to matrix
        matched_labels = match_samples_to_matrix(sample_names, label_data)
        print(f"Successfully matched {len(matched_labels['known_label'])} samples")

        # Create output directory
        output_dir = Path(args.output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
        print(f"Output directory: {output_dir.absolute()}")

        # Generate output filename base
        if args.output_name:
            output_name_base = args.output_name
        else:
            matrix_name = Path(args.matrix).stem
            output_name_base = f"{matrix_name}_{args.method}_{args.color_type}"

        # Two plots - known and predicted labels
        print(f"Generating {args.method.upper()} plots for known and predicted labels...")

        # Plot 1: Known labels
        title_known = f"{args.title} - Known Labels" if args.title else "Known Labels"
        fig_known = plot_dim_reduced(
            matrix=matrix,
            labels=matched_labels['known_label'],
            method=args.method,
            color_type=args.color_type
        )

        output_path_known = output_dir / f"{output_name_base}_known.{args.format}"
        print(f"Saving known labels plot to: {output_path_known.absolute()}")
        fig_known.save(output_path_known, dpi=args.dpi, bbox_inches='tight')

        # Plot 2: Predicted labels
        title_predicted = f"{args.title} - Predicted Labels" if args.title else "Predicted Labels"
        fig_predicted = plot_dim_reduced(
            matrix=matrix,
            labels=matched_labels['predicted_label'],
            method=args.method,
            color_type=args.color_type
        )

        output_path_predicted = output_dir / f"{output_name_base}_predicted.{args.format}"
        print(f"Saving predicted labels plot to: {output_path_predicted.absolute()}")
        fig_predicted.save(output_path_predicted, dpi=args.dpi, bbox_inches='tight')

        print("Both plots saved successfully!")

    except Exception as e:
        print(f"Error: {e}")
        return 1

    return 0

if __name__ == "__main__":
    exit(main())